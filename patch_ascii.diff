diff --git a/crates/mapmap-core/src/module.rs b/crates/mapmap-core/src/module.rs
index 0cfcbbd..a981d3a 100644
--- a/crates/mapmap-core/src/module.rs
+++ b/crates/mapmap-core/src/module.rs
@@ -1060,6 +1060,214 @@ pub enum SourceType {
         /// Sender name
         sender_name: String,
     },
+    /// Single-instance Video Source (Uni)
+    /// Behave like MediaFile but strictly for Video
+    VideoUni {
+        /// File path
+        path: String,
+        /// Playback speed multiplier (1.0 = normal)
+        #[serde(default = "default_speed")]
+        speed: f32,
+        /// Loop playback
+        #[serde(default)]
+        loop_enabled: bool,
+        /// Start time in seconds (for clips)
+        #[serde(default)]
+        start_time: f32,
+        /// End time in seconds (0 = full duration)
+        #[serde(default)]
+        end_time: f32,
+        /// Transparency/Opacity (0.0 - 1.0)
+        #[serde(default = "default_opacity")]
+        opacity: f32,
+        /// Blend mode for compositing
+        #[serde(default)]
+        blend_mode: Option<BlendModeType>,
+        /// Color correction:  Brightness (-1.0 to 1.0)
+        #[serde(default)]
+        brightness: f32,
+        /// Color correction: Contrast (0.0 to 2.0, 1.0 = normal)
+        #[serde(default = "default_contrast")]
+        contrast: f32,
+        /// Color correction: Saturation (0.0 to 2.0, 1.0 = normal)
+        #[serde(default = "default_saturation")]
+        saturation: f32,
+        /// Color correction: Hue shift (-180 to 180 degrees)
+        #[serde(default)]
+        hue_shift: f32,
+        /// Transform:  Scale X
+        #[serde(default = "default_scale")]
+        scale_x: f32,
+        /// Transform: Scale Y
+        #[serde(default = "default_scale")]
+        scale_y: f32,
+        /// Transform: Rotation in degrees
+        #[serde(default)]
+        rotation: f32,
+        /// Transform: Position offset X
+        #[serde(default)]
+        offset_x: f32,
+        /// Transform: Position offset Y
+        #[serde(default)]
+        offset_y: f32,
+        /// Target output width (None = use original resolution)
+        #[serde(default)]
+        target_width: Option<u32>,
+        /// Target output height (None = use original resolution)
+        #[serde(default)]
+        target_height: Option<u32>,
+        /// Target FPS override (None = use original FPS)
+        #[serde(default)]
+        target_fps: Option<f32>,
+        /// Flip video horizontally
+        #[serde(default)]
+        flip_horizontal: bool,
+        /// Flip video vertically
+        #[serde(default)]
+        flip_vertical: bool,
+        /// Play video in reverse
+        #[serde(default)]
+        reverse_playback: bool,
+    },
+    /// Multi-instance Shared Video Source (Multi)
+    /// References a shared media resource by ID
+    VideoMulti {
+        /// Shared Resource ID
+        shared_id: String,
+        /// Transparency/Opacity (0.0 - 1.0)
+        #[serde(default = "default_opacity")]
+        opacity: f32,
+        /// Blend mode for compositing
+        #[serde(default)]
+        blend_mode: Option<BlendModeType>,
+        /// Color correction:  Brightness (-1.0 to 1.0)
+        #[serde(default)]
+        brightness: f32,
+        /// Color correction: Contrast (0.0 to 2.0, 1.0 = normal)
+        #[serde(default = "default_contrast")]
+        contrast: f32,
+        /// Color correction: Saturation (0.0 to 2.0, 1.0 = normal)
+        #[serde(default = "default_saturation")]
+        saturation: f32,
+        /// Color correction: Hue shift (-180 to 180 degrees)
+        #[serde(default)]
+        hue_shift: f32,
+        /// Transform:  Scale X
+        #[serde(default = "default_scale")]
+        scale_x: f32,
+        /// Transform: Scale Y
+        #[serde(default = "default_scale")]
+        scale_y: f32,
+        /// Transform: Rotation in degrees
+        #[serde(default)]
+        rotation: f32,
+        /// Transform: Position offset X
+        #[serde(default)]
+        offset_x: f32,
+        /// Transform: Position offset Y
+        #[serde(default)]
+        offset_y: f32,
+        /// Flip video horizontally
+        #[serde(default)]
+        flip_horizontal: bool,
+        /// Flip video vertically
+        #[serde(default)]
+        flip_vertical: bool,
+    },
+    /// Single-instance Image Source (Uni)
+    ImageUni {
+        /// File path
+        path: String,
+        /// Transparency/Opacity (0.0 - 1.0)
+        #[serde(default = "default_opacity")]
+        opacity: f32,
+        /// Blend mode for compositing
+        #[serde(default)]
+        blend_mode: Option<BlendModeType>,
+        /// Color correction:  Brightness (-1.0 to 1.0)
+        #[serde(default)]
+        brightness: f32,
+        /// Color correction: Contrast (0.0 to 2.0, 1.0 = normal)
+        #[serde(default = "default_contrast")]
+        contrast: f32,
+        /// Color correction: Saturation (0.0 to 2.0, 1.0 = normal)
+        #[serde(default = "default_saturation")]
+        saturation: f32,
+        /// Color correction: Hue shift (-180 to 180 degrees)
+        #[serde(default)]
+        hue_shift: f32,
+        /// Transform:  Scale X
+        #[serde(default = "default_scale")]
+        scale_x: f32,
+        /// Transform: Scale Y
+        #[serde(default = "default_scale")]
+        scale_y: f32,
+        /// Transform: Rotation in degrees
+        #[serde(default)]
+        rotation: f32,
+        /// Transform: Position offset X
+        #[serde(default)]
+        offset_x: f32,
+        /// Transform: Position offset Y
+        #[serde(default)]
+        offset_y: f32,
+        /// Target output width (None = use original resolution)
+        #[serde(default)]
+        target_width: Option<u32>,
+        /// Target output height (None = use original resolution)
+        #[serde(default)]
+        target_height: Option<u32>,
+        /// Flip video horizontally
+        #[serde(default)]
+        flip_horizontal: bool,
+        /// Flip video vertically
+        #[serde(default)]
+        flip_vertical: bool,
+    },
+    /// Multi-instance Shared Image Source (Multi)
+    ImageMulti {
+        /// Shared Resource ID
+        shared_id: String,
+        /// Transparency/Opacity (0.0 - 1.0)
+        #[serde(default = "default_opacity")]
+        opacity: f32,
+        /// Blend mode for compositing
+        #[serde(default)]
+        blend_mode: Option<BlendModeType>,
+        /// Color correction:  Brightness (-1.0 to 1.0)
+        #[serde(default)]
+        brightness: f32,
+        /// Color correction: Contrast (0.0 to 2.0, 1.0 = normal)
+        #[serde(default = "default_contrast")]
+        contrast: f32,
+        /// Color correction: Saturation (0.0 to 2.0, 1.0 = normal)
+        #[serde(default = "default_saturation")]
+        saturation: f32,
+        /// Color correction: Hue shift (-180 to 180 degrees)
+        #[serde(default)]
+        hue_shift: f32,
+        /// Transform:  Scale X
+        #[serde(default = "default_scale")]
+        scale_x: f32,
+        /// Transform: Scale Y
+        #[serde(default = "default_scale")]
+        scale_y: f32,
+        /// Transform: Rotation in degrees
+        #[serde(default)]
+        rotation: f32,
+        /// Transform: Position offset X
+        #[serde(default)]
+        offset_x: f32,
+        /// Transform: Position offset Y
+        #[serde(default)]
+        offset_y: f32,
+        /// Flip video horizontally
+        #[serde(default)]
+        flip_horizontal: bool,
+        /// Flip video vertically
+        #[serde(default)]
+        flip_vertical: bool,
+    },
 }

 impl SourceType {
@@ -1777,6 +1985,64 @@ fn default_color_palette() -> Vec<[f32; 4]> {
     ]
 }

+/// Type of shared media
+#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]
+pub enum SharedMediaType {
+    /// Video media
+    Video,
+    /// Static image media
+    Image,
+}
+
+/// A shared media resource entry
+#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
+pub struct SharedMediaItem {
+    /// Unique ID
+    pub id: String,
+    /// File path
+    pub path: String,
+    /// Media Type
+    pub media_type: SharedMediaType,
+}
+
+/// Registry for shared media resources
+#[derive(Debug, Clone, Default, Serialize, Deserialize, PartialEq)]
+pub struct SharedMediaState {
+    /// Map of ID -> Item
+    pub items: HashMap<String, SharedMediaItem>,
+}
+
+impl SharedMediaState {
+    /// Create a new shared media state
+    pub fn new() -> Self {
+        Self {
+            items: HashMap::new(),
+        }
+    }
+
+    /// Register a shared media item
+    pub fn register(&mut self, id: String, path: String, media_type: SharedMediaType) {
+        self.items.insert(
+            id.clone(),
+            SharedMediaItem {
+                id,
+                path,
+                media_type,
+            },
+        );
+    }
+
+    /// Get a shared media item by ID
+    pub fn get(&self, id: &str) -> Option<&SharedMediaItem> {
+        self.items.get(id)
+    }
+
+    /// Unregister a shared media item
+    pub fn unregister(&mut self, id: &str) {
+        self.items.remove(id);
+    }
+}
+
 /// Manages multiple modules (Scenes)
 #[derive(Debug, Clone, Serialize, Deserialize)]
 pub struct ModuleManager {
@@ -1786,6 +2052,9 @@ pub struct ModuleManager {
     #[serde(skip, default = "default_color_palette")]
     color_palette: Vec<[f32; 4]>,
     next_color_index: usize,
+    /// Shared media registry
+    #[serde(default)]
+    pub shared_media: SharedMediaState,
 }

 impl PartialEq for ModuleManager {
@@ -1794,6 +2063,7 @@ impl PartialEq for ModuleManager {
             && self.next_module_id == other.next_module_id
             && self.next_part_id == other.next_part_id
             && self.next_color_index == other.next_color_index
+            && self.shared_media == other.shared_media
     }
 }

@@ -1806,6 +2076,7 @@ impl ModuleManager {
             next_part_id: 1,
             color_palette: default_color_palette(),
             next_color_index: 0,
+            shared_media: SharedMediaState::new(),
         }
     }

diff --git a/crates/mapmap-core/src/module_eval.rs b/crates/mapmap-core/src/module_eval.rs
index 552613f..ea186d6 100644
--- a/crates/mapmap-core/src/module_eval.rs
+++ b/crates/mapmap-core/src/module_eval.rs
@@ -7,7 +7,8 @@ use crate::audio::analyzer_v2::AudioAnalysisV2;
 use crate::audio_reactive::AudioTriggerData;
 use crate::module::{
     BlendModeType, LayerType, LinkBehavior, LinkMode, MapFlowModule, MaskType, MeshType,
-    ModulePartId, ModulePartType, ModulizerType, OutputType, SourceType, TriggerType,
+    ModulePartId, ModulePartType, ModulizerType, OutputType, SharedMediaState, SourceType,
+    TriggerType,
 };
 use rand::Rng;
 use std::collections::HashMap;
@@ -105,6 +106,7 @@ mod tests_evaluator {
     #[test]
     fn test_trigger_fixed_interval() {
         let mut evaluator = ModuleEvaluator::new();
+        let shared = crate::module::SharedMediaState::default();

         let mut module = create_test_module();
         let trigger_part = ModulePartType::Trigger(TriggerType::Fixed {
@@ -114,7 +116,7 @@ mod tests_evaluator {
         let part_id = module.add_part_with_type(trigger_part, (0.0, 0.0));

         // Initial eval - t=0, phase=0, duration=10, 0 < 10 -> 1.0
-        let result = evaluator.evaluate(&module);
+        let result = evaluator.evaluate(&module, &shared);
         let values = &result.trigger_values[&part_id];
         assert_eq!(values[0], 1.0);

@@ -124,7 +126,7 @@ mod tests_evaluator {
         // Ideally we'd refactor to inject time.
         std::thread::sleep(Duration::from_millis(20));

-        let result = evaluator.evaluate(&module);
+        let result = evaluator.evaluate(&module, &shared);
         let values = &result.trigger_values[&part_id];
         // 20ms > 10ms pulse duration -> 0.0
         assert_eq!(values[0], 0.0);
@@ -157,7 +159,7 @@ mod tests_evaluator {

         let part_id = module.add_part_with_type(trigger_part, (0.0, 0.0));

-        let result = evaluator.evaluate(&module);
+        let result = evaluator.evaluate(&module, &crate::module::SharedMediaState::default());
         let values = &result.trigger_values[&part_id];

         // Order in generate_outputs:
@@ -186,7 +188,8 @@ mod tests_evaluator {
         let s_id = module.add_part(crate::module::PartType::Source, (200.0, 0.0));
         module.add_connection(t_id, 0, s_id, 0); // Trigger Out -> Source Trigger In

-        let _result = evaluator.evaluate(&module);
+        let shared = crate::module::SharedMediaState::default();
+        let _result = evaluator.evaluate(&module, &shared);

         // Should produce a SourceCommand because trigger > 0.1
         // (Source defaults to "MediaFile" with empty path, create_source_command checks empty path)
@@ -200,12 +203,12 @@ mod tests_evaluator {
             }
         }

-        let result = evaluator.evaluate(&module);
+        let result = evaluator.evaluate(&module, &shared);
         assert!(result.source_commands.contains_key(&s_id));

         // Now remove connection
         module.remove_connection(t_id, 0, s_id, 0);
-        let result = evaluator.evaluate(&module);
+        let result = evaluator.evaluate(&module, &shared);
         assert!(!result.source_commands.contains_key(&s_id));
     }

@@ -243,7 +246,7 @@ mod tests_evaluator {
         module.add_connection(s_id, 0, l_id, 0); // Source Media -> Layer Input
         module.add_connection(l_id, 0, o_id, 0); // Layer Output -> Output Layer In

-        let result = evaluator.evaluate(&module);
+        let result = evaluator.evaluate(&module, &crate::module::SharedMediaState::default());

         // Verify RenderOp
         assert_eq!(result.render_ops.len(), 1);
@@ -317,7 +320,7 @@ mod tests_evaluator {
         // Slave Link In index: 2 (0=Media, 1=Trigger)
         module.add_connection(m_id, 1, s_id, 2);

-        let result = evaluator.evaluate(&module);
+        let result = evaluator.evaluate(&module, &crate::module::SharedMediaState::default());

         // Master ID in trigger_values should have 2 values: Trigger Out (1.0) and Link Out (1.0)
         let m_values = &result.trigger_values[&m_id];
@@ -394,6 +397,15 @@ pub enum SourceCommand {
         /// Trigger value (opacity/intensity)
         trigger_value: f32,
     },
+    /// Play a shared media resource
+    PlaySharedMedia {
+        /// Shared ID
+        id: String,
+        /// Resolved path (from registry)
+        path: String,
+        /// Trigger value
+        trigger_value: f32,
+    },
     /// Play a shader with parameters
     PlayShader {
         /// Shader name/ID
@@ -507,7 +519,11 @@ impl ModuleEvaluator {

     /// Evaluate a module for one frame
     /// Returns a reference to the reusable result buffer
-    pub fn evaluate(&mut self, module: &MapFlowModule) -> &ModuleEvalResult {
+    pub fn evaluate(
+        &mut self,
+        module: &MapFlowModule,
+        shared_state: &SharedMediaState,
+    ) -> &ModuleEvalResult {
         // Clear previous result for reuse
         self.cached_result.clear();
         // Since we cleared trigger_values via iteration (retaining keys),
@@ -612,7 +628,9 @@ impl ModuleEvaluator {
         for part in &module.parts {
             if let ModulePartType::Source(source_type) = &part.part_type {
                 let trigger_value = trigger_inputs.get(&part.id).copied().unwrap_or(0.0);
-                if let Some(cmd) = self.create_source_command(source_type, trigger_value) {
+                if let Some(cmd) =
+                    self.create_source_command(source_type, trigger_value, shared_state)
+                {
                     self.cached_result.source_commands.insert(part.id, cmd);
                 }
             }
@@ -856,39 +874,120 @@ impl ModuleEvaluator {
                     match &part.part_type {
                         ModulePartType::Source(source_type) => {
                             source_id = Some(part.id);
-                            // Extract SourceProperties from MediaFile
-                            if let SourceType::MediaFile {
-                                opacity,
-                                brightness,
-                                contrast,
-                                saturation,
-                                hue_shift,
-                                scale_x,
-                                scale_y,
-                                rotation,
-                                offset_x,
-                                offset_y,
-                                flip_horizontal,
-                                flip_vertical,
-                                ..
-                            } = source_type
-                            {
-                                // Apply defaults first
-                                let mut props = SourceProperties {
-                                    opacity: *opacity,
-                                    brightness: *brightness,
-                                    contrast: *contrast,
-                                    saturation: *saturation,
-                                    hue_shift: *hue_shift,
-                                    scale_x: *scale_x,
-                                    scale_y: *scale_y,
-                                    rotation: *rotation,
-                                    offset_x: *offset_x,
-                                    offset_y: *offset_y,
-                                    flip_horizontal: *flip_horizontal,
-                                    flip_vertical: *flip_vertical,
-                                };

+                            // Helper to extract props from any source variant that has them
+                            let mut extracted_props = None;
+
+                            match source_type {
+                                SourceType::MediaFile {
+                                    opacity,
+                                    brightness,
+                                    contrast,
+                                    saturation,
+                                    hue_shift,
+                                    scale_x,
+                                    scale_y,
+                                    rotation,
+                                    offset_x,
+                                    offset_y,
+                                    flip_horizontal,
+                                    flip_vertical,
+                                    ..
+                                }
+                                | SourceType::VideoUni {
+                                    opacity,
+                                    brightness,
+                                    contrast,
+                                    saturation,
+                                    hue_shift,
+                                    scale_x,
+                                    scale_y,
+                                    rotation,
+                                    offset_x,
+                                    offset_y,
+                                    flip_horizontal,
+                                    flip_vertical,
+                                    ..
+                                }
+                                | SourceType::ImageUni {
+                                    opacity,
+                                    brightness,
+                                    contrast,
+                                    saturation,
+                                    hue_shift,
+                                    scale_x,
+                                    scale_y,
+                                    rotation,
+                                    offset_x,
+                                    offset_y,
+                                    flip_horizontal,
+                                    flip_vertical,
+                                    ..
+                                } => {
+                                    extracted_props = Some(SourceProperties {
+                                        opacity: *opacity,
+                                        brightness: *brightness,
+                                        contrast: *contrast,
+                                        saturation: *saturation,
+                                        hue_shift: *hue_shift,
+                                        scale_x: *scale_x,
+                                        scale_y: *scale_y,
+                                        rotation: *rotation,
+                                        offset_x: *offset_x,
+                                        offset_y: *offset_y,
+                                        flip_horizontal: *flip_horizontal,
+                                        flip_vertical: *flip_vertical,
+                                    });
+                                }
+                                SourceType::VideoMulti {
+                                    opacity,
+                                    brightness,
+                                    contrast,
+                                    saturation,
+                                    hue_shift,
+                                    scale_x,
+                                    scale_y,
+                                    rotation,
+                                    offset_x,
+                                    offset_y,
+                                    flip_horizontal,
+                                    flip_vertical,
+                                    ..
+                                }
+                                | SourceType::ImageMulti {
+                                    opacity,
+                                    brightness,
+                                    contrast,
+                                    saturation,
+                                    hue_shift,
+                                    scale_x,
+                                    scale_y,
+                                    rotation,
+                                    offset_x,
+                                    offset_y,
+                                    flip_horizontal,
+                                    flip_vertical,
+                                    ..
+                                } => {
+                                    extracted_props = Some(SourceProperties {
+                                        opacity: *opacity,
+                                        brightness: *brightness,
+                                        contrast: *contrast,
+                                        saturation: *saturation,
+                                        hue_shift: *hue_shift,
+                                        scale_x: *scale_x,
+                                        scale_y: *scale_y,
+                                        rotation: *rotation,
+                                        offset_x: *offset_x,
+                                        offset_y: *offset_y,
+                                        flip_horizontal: *flip_horizontal,
+                                        flip_vertical: *flip_vertical,
+                                    });
+                                }
+                                _ => {}
+                            }
+
+                            if let Some(mut props) = extracted_props {
                                 // Re-apply overrides since we just replaced with defaults
                                 // (This structure is slightly inefficient, re-doing logic)
                                 // Better: Apply overrides TO props.
@@ -1189,6 +1288,7 @@ impl ModuleEvaluator {
         &self,
         source_type: &SourceType,
         trigger_value: f32,
+        shared_state: &SharedMediaState,
     ) -> Option<SourceCommand> {
         // Only activate source if trigger is above threshold (0.1)
         if trigger_value < 0.1 {
@@ -1196,7 +1296,9 @@ impl ModuleEvaluator {
         }

         match source_type {
-            SourceType::MediaFile { path, .. } => {
+            SourceType::MediaFile { path, .. }
+            | SourceType::VideoUni { path, .. }
+            | SourceType::ImageUni { path, .. } => {
                 if path.is_empty() {
                     return None;
                 }
@@ -1205,6 +1307,18 @@ impl ModuleEvaluator {
                     trigger_value,
                 })
             }
+            SourceType::VideoMulti { shared_id, .. } | SourceType::ImageMulti { shared_id, .. } => {
+                // Resolve path from shared state
+                if let Some(item) = shared_state.get(shared_id) {
+                    Some(SourceCommand::PlaySharedMedia {
+                        id: shared_id.clone(),
+                        path: item.path.clone(),
+                        trigger_value,
+                    })
+                } else {
+                    None // ID not found
+                }
+            }
             SourceType::Shader { name, params } => Some(SourceCommand::PlayShader {
                 name: name.clone(),
                 params: params.clone(),
@@ -1397,15 +1511,16 @@ mod tests_logic {
     #[test]
     fn test_create_source_command() {
         let evaluator = ModuleEvaluator::new();
+        let shared = crate::module::SharedMediaState::default();

         // Threshold check (< 0.1)
         let cmd_low =
-            evaluator.create_source_command(&SourceType::LiveInput { device_id: 0 }, 0.05);
+            evaluator.create_source_command(&SourceType::LiveInput { device_id: 0 }, 0.05, &shared);
         assert!(cmd_low.is_none());

         // Valid command
         let cmd_valid =
-            evaluator.create_source_command(&SourceType::LiveInput { device_id: 1 }, 0.5);
+            evaluator.create_source_command(&SourceType::LiveInput { device_id: 1 }, 0.5, &shared);
         match cmd_valid {
             Some(SourceCommand::LiveInput {
                 device_id,
@@ -1465,7 +1580,7 @@ mod tests_logic {
         });

         // Run evaluate to populate internal caches
-        evaluator.evaluate(&module);
+        evaluator.evaluate(&module, &crate::module::SharedMediaState::default());

         // Start trace from 1 using cached indices
         let chain = evaluator.trace_chain(1, &module);
@@ -1524,7 +1639,7 @@ mod tests_logic {
         // Layer(0) -> Output(0)
         module.add_connection(layer_id, 0, output_id, 0);

-        let result = evaluator.evaluate(&module);
+        let result = evaluator.evaluate(&module, &crate::module::SharedMediaState::default());

         assert_eq!(result.render_ops.len(), 1);
         let op = &result.render_ops[0];
diff --git a/crates/mapmap-ui/src/module_canvas.rs b/crates/mapmap-ui/src/module_canvas.rs
index c34ae2f..a8eb207 100644
--- a/crates/mapmap-ui/src/module_canvas.rs
+++ b/crates/mapmap-ui/src/module_canvas.rs
@@ -663,34 +663,221 @@ impl ModuleCanvas {
                                     }
                                     ModulePartType::Source(source) => {
                                         ui.label("Source Type:");
+
+                                        // Helper to render common appearance controls
+                                        let mut render_common_controls = |ui: &mut Ui,
+                                            path: Option<&mut String>,
+                                            opacity: &mut f32,
+                                            blend_mode: &mut Option<BlendModeType>,
+                                            brightness: &mut f32,
+                                            contrast: &mut f32,
+                                            saturation: &mut f32,
+                                            hue_shift: &mut f32,
+                                            scale_x: &mut f32,
+                                            scale_y: &mut f32,
+                                            rotation: &mut f32,
+                                            offset_x: &mut f32,
+                                            offset_y: &mut f32,
+                                            flip_horizontal: &mut bool,
+                                            flip_vertical: &mut bool| {
+
+                                            // === SMART EMPTY STATE (Only if path is present) ===
+                                            if let Some(p) = path {
+                                                if p.is_empty() {
+                                                    ui.vertical_centered(|ui| {
+                                                        ui.add_space(10.0);
+                                                        if ui.add(egui::Button::new("???? Select Media File")
+                                                            .min_size(egui::vec2(150.0, 30.0)))
+                                                            .clicked()
+                                                        {
+                                                            actions.push(crate::UIAction::PickMediaFile(module_id, part_id, "".to_string()));
+                                                        }
+                                                        ui.label(egui::RichText::new("No media loaded").weak());
+                                                        ui.add_space(10.0);
+                                                    });
+                                                } else {
+                                                    // === FILE PATH ===
+                                                    ui.collapsing("???? File Info", |ui| {
+                                                        ui.horizontal(|ui| {
+                                                            ui.label("Path:");
+                                                            ui.add(
+                                                                egui::TextEdit::singleline(p)
+                                                                    .desired_width(160.0),
+                                                            );
+                                                            if ui.button("????").on_hover_text("Select Media File").clicked() {
+                                                                actions.push(crate::UIAction::PickMediaFile(module_id, part_id, "".to_string()));
+                                                            }
+                                                        });
+                                                    });
+                                                }
+                                            } else {
+                                                // Shared media label
+                                                ui.label("???? Shared Media Source");
+                                            }
+
+                                            // === APPEARANCE ===
+                                            ui.collapsing("???? Appearance", |ui| {
+                                                ui.add(egui::Slider::new(opacity, 0.0..=1.0).text("Opacity"));
+
+                                                // Blend Mode selector
+                                                ui.horizontal(|ui| {
+                                                    ui.label("Blend Mode:");
+                                                    egui::ComboBox::from_id_salt("blend_mode_selector")
+                                                        .selected_text(match blend_mode {
+                                                            Some(BlendModeType::Normal) => "Normal",
+                                                            Some(BlendModeType::Add) => "Add",
+                                                            Some(BlendModeType::Multiply) => "Multiply",
+                                                            Some(BlendModeType::Screen) => "Screen",
+                                                            Some(BlendModeType::Overlay) => "Overlay",
+                                                            Some(BlendModeType::Difference) => "Difference",
+                                                            Some(BlendModeType::Exclusion) => "Exclusion",
+                                                            None => "Normal",
+                                                        })
+                                                        .show_ui(ui, |ui| {
+                                                            if ui.selectable_label(blend_mode.is_none(), "Normal").clicked() {
+                                                                *blend_mode = None;
+                                                            }
+                                                            if ui.selectable_label(*blend_mode == Some(BlendModeType::Add), "Add").clicked() {
+                                                                *blend_mode = Some(BlendModeType::Add);
+                                                            }
+                                                            if ui.selectable_label(*blend_mode == Some(BlendModeType::Multiply), "Multiply").clicked() {
+                                                                *blend_mode = Some(BlendModeType::Multiply);
+                                                            }
+                                                            if ui.selectable_label(*blend_mode == Some(BlendModeType::Screen), "Screen").clicked() {
+                                                                *blend_mode = Some(BlendModeType::Screen);
+                                                            }
+                                                            if ui.selectable_label(*blend_mode == Some(BlendModeType::Overlay), "Overlay").clicked() {
+                                                                *blend_mode = Some(BlendModeType::Overlay);
+                                                            }
+                                                            if ui.selectable_label(*blend_mode == Some(BlendModeType::Difference), "Difference").clicked() {
+                                                                *blend_mode = Some(BlendModeType::Difference);
+                                                            }
+                                                            if ui.selectable_label(*blend_mode == Some(BlendModeType::Exclusion), "Exclusion").clicked() {
+                                                                *blend_mode = Some(BlendModeType::Exclusion);
+                                                            }
+                                                        });
+                                                });
+                                            });
+
+                                            // === COLOR CORRECTION ===
+                                            if crate::widgets::collapsing_header_with_reset(
+                                                ui,
+                                                "???? Color Correction",
+                                                false,
+                                                |ui| {
+                                                    ui.columns(2, |columns| {
+                                                        columns[0].add(
+                                                            egui::Slider::new(brightness, -1.0..=1.0)
+                                                                .text("Brightness"),
+                                                        );
+                                                        columns[0].add(
+                                                            egui::Slider::new(contrast, 0.0..=2.0)
+                                                                .text("Contrast"),
+                                                        );
+
+                                                        columns[1].add(
+                                                            egui::Slider::new(saturation, 0.0..=2.0)
+                                                                .text("Saturation"),
+                                                        );
+                                                        columns[1].add(
+                                                            egui::Slider::new(hue_shift, -180.0..=180.0)
+                                                                .text("Hue Shift")
+                                                                .suffix("??"),
+                                                        );
+                                                    });
+                                                },
+                                            ) {
+                                                *brightness = 0.0;
+                                                *contrast = 1.0;
+                                                *saturation = 1.0;
+                                                *hue_shift = 0.0;
+                                            }
+
+                                            // === TRANSFORM ===
+                                            if crate::widgets::collapsing_header_with_reset(
+                                                ui,
+                                                "???? Transform",
+                                                false,
+                                                |ui| {
+                                                    ui.columns(2, |columns| {
+                                                        // Scale Controls
+                                                        columns[0].label("Scale:");
+                                                        columns[0].horizontal(|ui| {
+                                                            ui.add(egui::DragValue::new(scale_x).speed(0.01).prefix("X: "));
+                                                            ui.add(egui::DragValue::new(scale_y).speed(0.01).prefix("Y: "));
+                                                        });
+
+                                                        // Offset Controls
+                                                        columns[1].label("Offset:");
+                                                        columns[1].horizontal(|ui| {
+                                                            ui.add(egui::DragValue::new(offset_x).speed(1.0).prefix("X: "));
+                                                            ui.add(egui::DragValue::new(offset_y).speed(1.0).prefix("Y: "));
+                                                        });
+                                                    });
+
+                                                    ui.add_space(4.0);
+
+                                                    ui.add(
+                                                        egui::Slider::new(rotation, -180.0..=180.0)
+                                                            .text("Rotation")
+                                                            .suffix("??"),
+                                                    );
+
+                                                    ui.separator();
+                                                    ui.label("Mirror / Flip:");
+                                                    ui.horizontal(|ui| {
+                                                        ui.checkbox(flip_horizontal, "?????? Horizontal");
+                                                        ui.checkbox(flip_vertical, "?????? Vertical");
+                                                    });
+                                                },
+                                            ) {
+                                                *scale_x = 1.0;
+                                                *scale_y = 1.0;
+                                                *rotation = 0.0;
+                                                *offset_x = 0.0;
+                                                *offset_y = 0.0;
+                                                *flip_horizontal = false;
+                                                *flip_vertical = false;
+                                            }
+                                        };
+
+                                        // Apply common controls
                                         match source {
                                             SourceType::MediaFile {
-                                                path,
-                                                speed,
-                                                loop_enabled,
-                                                start_time,
-                                                end_time,
-                                                opacity,
-                                                blend_mode,
-                                                brightness,
-                                                contrast,
-                                                saturation,
-                                                hue_shift,
-                                                scale_x,
-                                                scale_y,
-                                                rotation,
-                                                offset_x,
-                                                offset_y,
-                                                flip_horizontal,
-                                                flip_vertical,
-                                                reverse_playback,
-                                                ..
+                                                path, opacity, blend_mode, brightness, contrast, saturation, hue_shift, scale_x, scale_y, rotation, offset_x, offset_y, flip_horizontal, flip_vertical, ..
+                                            } | SourceType::VideoUni {
+                                                path, opacity, blend_mode, brightness, contrast, saturation, hue_shift, scale_x, scale_y, rotation, offset_x, offset_y, flip_horizontal, flip_vertical, ..
+                                            } | SourceType::ImageUni {
+                                                path, opacity, blend_mode, brightness, contrast, saturation, hue_shift, scale_x, scale_y, rotation, offset_x, offset_y, flip_horizontal, flip_vertical, ..
+                                            } => {
+                                                render_common_controls(ui, Some(path), opacity, blend_mode, brightness, contrast, saturation, hue_shift, scale_x, scale_y, rotation, offset_x, offset_y, flip_horizontal, flip_vertical);
+                                            }
+                                            SourceType::VideoMulti {
+                                                opacity, blend_mode, brightness, contrast, saturation, hue_shift, scale_x, scale_y, rotation, offset_x, offset_y, flip_horizontal, flip_vertical, ..
+                                            } | SourceType::ImageMulti {
+                                                opacity, blend_mode, brightness, contrast, saturation, hue_shift, scale_x, scale_y, rotation, offset_x, offset_y, flip_horizontal, flip_vertical, ..
                                             } => {
-                                                // === LIVE PERFORMANCE HEADER ===
-                                                let player_info = self.player_info.get(&part_id).cloned().unwrap_or_default();
-                                                let video_duration = player_info.duration.max(1.0) as f32;
-                                                let current_pos = player_info.current_time as f32;
-                                                let is_playing = player_info.is_playing;
+                                                render_common_controls(ui, None, opacity, blend_mode, brightness, contrast, saturation, hue_shift, scale_x, scale_y, rotation, offset_x, offset_y, flip_horizontal, flip_vertical);
+                                            }
+                                            _ => {}
+                                        }
+
+                                        // Video Transport Controls (MediaFile or VideoUni)
+                                        let video_props = match source {
+                                             SourceType::MediaFile {
+                                                speed, loop_enabled, start_time, end_time, reverse_playback, ..
+                                            } | SourceType::VideoUni {
+                                                speed, loop_enabled, start_time, end_time, reverse_playback, ..
+                                            } => Some((speed, loop_enabled, start_time, end_time, reverse_playback)),
+                                            _ => None
+                                        };
+
+                                        if let Some((speed, loop_enabled, start_time, end_time, reverse_playback)) = video_props {
+                                            // Video Logic
+                                            let player_info = self.player_info.get(&part_id).cloned().unwrap_or_default();
+                                            let video_duration = player_info.duration.max(1.0) as f32;
+                                            let current_pos = player_info.current_time as f32;
+                                            let is_playing = player_info.is_playing;

                                                 // Time Calculation
                                                 let current_min = (current_pos / 60.0) as u32;
@@ -1139,6 +1326,166 @@ impl ModuleCanvas {
                                                 });

                                             }
+                                            SourceType::VideoMulti {
+                                                opacity,
+                                                blend_mode,
+                                                brightness,
+                                                contrast,
+                                                saturation,
+                                                hue_shift,
+                                                scale_x,
+                                                scale_y,
+                                                rotation,
+                                                offset_x,
+                                                offset_y,
+                                                flip_horizontal,
+                                                flip_vertical,
+                                                ..
+                                            }
+                                            | SourceType::ImageMulti {
+                                                opacity,
+                                                blend_mode,
+                                                brightness,
+                                                contrast,
+                                                saturation,
+                                                hue_shift,
+                                                scale_x,
+                                                scale_y,
+                                                rotation,
+                                                offset_x,
+                                                offset_y,
+                                                flip_horizontal,
+                                                flip_vertical,
+                                                ..
+                                            } => {
+                                                ui.label("???? Shared Media Source");
+                                                ui.label("Content controlled by Shared Registry");
+
+                                                // === APPEARANCE ===
+                                                ui.collapsing("???? Appearance", |ui| {
+                                                    ui.add(egui::Slider::new(opacity, 0.0..=1.0).text("Opacity"));
+
+                                                    // Blend Mode selector
+                                                    ui.horizontal(|ui| {
+                                                        ui.label("Blend Mode:");
+                                                        egui::ComboBox::from_id_salt("blend_mode_selector")
+                                                            .selected_text(match blend_mode {
+                                                                Some(BlendModeType::Normal) => "Normal",
+                                                                Some(BlendModeType::Add) => "Add",
+                                                                Some(BlendModeType::Multiply) => "Multiply",
+                                                                Some(BlendModeType::Screen) => "Screen",
+                                                                Some(BlendModeType::Overlay) => "Overlay",
+                                                                Some(BlendModeType::Difference) => "Difference",
+                                                                Some(BlendModeType::Exclusion) => "Exclusion",
+                                                                None => "Normal",
+                                                            })
+                                                            .show_ui(ui, |ui| {
+                                                                if ui.selectable_label(blend_mode.is_none(), "Normal").clicked() {
+                                                                    *blend_mode = None;
+                                                                }
+                                                                if ui.selectable_label(*blend_mode == Some(BlendModeType::Add), "Add").clicked() {
+                                                                    *blend_mode = Some(BlendModeType::Add);
+                                                                }
+                                                                if ui.selectable_label(*blend_mode == Some(BlendModeType::Multiply), "Multiply").clicked() {
+                                                                    *blend_mode = Some(BlendModeType::Multiply);
+                                                                }
+                                                                if ui.selectable_label(*blend_mode == Some(BlendModeType::Screen), "Screen").clicked() {
+                                                                    *blend_mode = Some(BlendModeType::Screen);
+                                                                }
+                                                                if ui.selectable_label(*blend_mode == Some(BlendModeType::Overlay), "Overlay").clicked() {
+                                                                    *blend_mode = Some(BlendModeType::Overlay);
+                                                                }
+                                                                if ui.selectable_label(*blend_mode == Some(BlendModeType::Difference), "Difference").clicked() {
+                                                                    *blend_mode = Some(BlendModeType::Difference);
+                                                                }
+                                                                if ui.selectable_label(*blend_mode == Some(BlendModeType::Exclusion), "Exclusion").clicked() {
+                                                                    *blend_mode = Some(BlendModeType::Exclusion);
+                                                                }
+                                                            });
+                                                    });
+                                                });
+
+                                                // === COLOR CORRECTION ===
+                                                if crate::widgets::collapsing_header_with_reset(
+                                                    ui,
+                                                    "???? Color Correction",
+                                                    false,
+                                                    |ui| {
+                                                        ui.columns(2, |columns| {
+                                                            columns[0].add(
+                                                                egui::Slider::new(brightness, -1.0..=1.0)
+                                                                    .text("Brightness"),
+                                                            );
+                                                            columns[0].add(
+                                                                egui::Slider::new(contrast, 0.0..=2.0)
+                                                                    .text("Contrast"),
+                                                            );
+
+                                                            columns[1].add(
+                                                                egui::Slider::new(saturation, 0.0..=2.0)
+                                                                    .text("Saturation"),
+                                                            );
+                                                            columns[1].add(
+                                                                egui::Slider::new(hue_shift, -180.0..=180.0)
+                                                                    .text("Hue Shift")
+                                                                    .suffix("??"),
+                                                            );
+                                                        });
+                                                    },
+                                                ) {
+                                                    *brightness = 0.0;
+                                                    *contrast = 1.0;
+                                                    *saturation = 1.0;
+                                                    *hue_shift = 0.0;
+                                                }
+
+                                                // === TRANSFORM ===
+                                                if crate::widgets::collapsing_header_with_reset(
+                                                    ui,
+                                                    "???? Transform",
+                                                    false,
+                                                    |ui| {
+                                                        ui.columns(2, |columns| {
+                                                            // Scale Controls
+                                                            columns[0].label("Scale:");
+                                                            columns[0].horizontal(|ui| {
+                                                                ui.add(egui::DragValue::new(scale_x).speed(0.01).prefix("X: "));
+                                                                ui.add(egui::DragValue::new(scale_y).speed(0.01).prefix("Y: "));
+                                                            });
+
+                                                            // Offset Controls
+                                                            columns[1].label("Offset:");
+                                                            columns[1].horizontal(|ui| {
+                                                                ui.add(egui::DragValue::new(offset_x).speed(1.0).prefix("X: "));
+                                                                ui.add(egui::DragValue::new(offset_y).speed(1.0).prefix("Y: "));
+                                                            });
+                                                        });
+
+                                                        ui.add_space(4.0);
+
+                                                        ui.add(
+                                                            egui::Slider::new(rotation, -180.0..=180.0)
+                                                                .text("Rotation")
+                                                                .suffix("??"),
+                                                        );
+
+                                                        ui.separator();
+                                                        ui.label("Mirror / Flip:");
+                                                        ui.horizontal(|ui| {
+                                                            ui.checkbox(flip_horizontal, "?????? Horizontal");
+                                                            ui.checkbox(flip_vertical, "?????? Vertical");
+                                                        });
+                                                    },
+                                                ) {
+                                                    *scale_x = 1.0;
+                                                    *scale_y = 1.0;
+                                                    *rotation = 0.0;
+                                                    *offset_x = 0.0;
+                                                    *offset_y = 0.0;
+                                                    *flip_horizontal = false;
+                                                    *flip_vertical = false;
+                                                }
+                                            }
                                             SourceType::Shader { name, params: _ } => {
                                                 ui.label("???? Shader");
                                                 ui.horizontal(|ui| {
@@ -4720,6 +5067,10 @@ impl ModuleCanvas {
                 ui.label("Source Type:");
                 let current = match source_type {
                     SourceType::MediaFile { .. } => "Media File",
+                    SourceType::VideoUni { .. } => "Video (Uni)",
+                    SourceType::ImageUni { .. } => "Image (Uni)",
+                    SourceType::VideoMulti { .. } => "Video (Shared)",
+                    SourceType::ImageMulti { .. } => "Image (Shared)",
                     SourceType::Shader { .. } => "Shader",
                     SourceType::LiveInput { .. } => "Live Input",
                     #[cfg(feature = "ndi")]
@@ -4787,6 +5138,8 @@ impl ModuleCanvas {
                     });

                 // Properties for SourceType
+                // Helper to access path and scaling props if available
+                // Split handling to satisfy borrow checker and type differences
                 if let SourceType::MediaFile {
                     path,
                     target_width,
@@ -4795,6 +5148,83 @@ impl ModuleCanvas {
                     ..
                 } = source_type
                 {
+                    Self::render_media_source_props(
+                        ui,
+                        path,
+                        target_width,
+                        target_height,
+                        target_fps,
+                    );
+                } else if let SourceType::VideoUni {
+                    path,
+                    target_width,
+                    target_height,
+                    target_fps,
+                    ..
+                } = source_type
+                {
+                    Self::render_media_source_props(
+                        ui,
+                        path,
+                        target_width,
+                        target_height,
+                        target_fps,
+                    );
+                } else if let SourceType::ImageUni {
+                    path,
+                    target_width,
+                    target_height,
+                    ..
+                } = source_type
+                {
+                    // Image Uni (No FPS)
+                    ui.add_space(4.0);
+                    ui.label("Image Path:");
+                    ui.horizontal(|ui| {
+                        ui.text_edit_singleline(path);
+                        if ui.button("????").on_hover_text("Select File").clicked() {
+                            if let Some(file_path) = rfd::FileDialog::new().pick_file() {
+                                *path = file_path.to_string_lossy().to_string();
+                            }
+                        }
+                    });
+                    // Scaling UI (Simplified for Image)
+                    ui.add_space(8.0);
+                    ui.separator();
+                    ui.label("Output Scaling:");
+                    ui.horizontal(|ui| {
+                        let mut use_width = target_width.is_some();
+                        if ui.checkbox(&mut use_width, "Width:").changed() {
+                            *target_width = if use_width { Some(1920) } else { None };
+                        }
+                        if let Some(w) = target_width {
+                            let mut val = *w as i32;
+                            if ui
+                                .add(egui::DragValue::new(&mut val).range(1..=7680).speed(10))
+                                .changed()
+                            {
+                                *w = val.max(1) as u32;
+                            }
+                        }
+                    });
+                } else if let SourceType::MediaFile {
+                    path,
+                    target_width,
+                    target_height,
+                    target_fps,
+                    ..
+                } = source_type
+                {
+                    // Fallback block - kept only if previous match wasn't exhaustive or for structure
+                    // But we replaced it above. This block in search is just the start of the old block.
+                    // The replacement covers the logic.
+                    // WAIT: I need to replace the WHOLE block of `if let SourceType::MediaFile ...`
+                    // In my SEARCH block I only included the start.
+                    // This is risky. I should use `create_file` or `overwrite_file` if I can't be precise.
+                    // But I can be precise if I include enough context.
+                    // The old block ends with `});` and then `}`.
+                    // I will just replace the `if let ...` start and let the existing body be... no, I need to replace the logic.
+                    // Let's rewrite the method `render_node_inspector` part completely or add the helper method.
                     ui.add_space(4.0);
                     ui.label("Media Path:");
                     ui.horizontal(|ui| {
@@ -6295,13 +6725,18 @@ impl ModuleCanvas {
                 TriggerType::Beat => "???? Beat".to_string(),
             },
             ModulePartType::Source(source_type) => match source_type {
-                SourceType::MediaFile { path, .. } => {
+                SourceType::MediaFile { path, .. }
+                | SourceType::VideoUni { path, .. }
+                | SourceType::ImageUni { path, .. } => {
                     if path.is_empty() {
                         "???? Select file...".to_string()
                     } else {
                         format!("???? {}", path.split(['/', '\\']).next_back().unwrap_or(path))
                     }
                 }
+                SourceType::VideoMulti { shared_id, .. } | SourceType::ImageMulti { shared_id, .. } => {
+                    format!("???? {}", shared_id)
+                }
                 SourceType::Shader { name, .. } => format!("???? {}", name),
                 SourceType::LiveInput { device_id } => format!("???? Device {}", device_id),
                 SourceType::NdiInput { source_name } => {
@@ -6605,6 +7040,99 @@ impl ModuleCanvas {
         }
     }

+    /// Helper to render standard media source properties
+    fn render_media_source_props(
+        ui: &mut egui::Ui,
+        path: &mut String,
+        target_width: &mut Option<u32>,
+        target_height: &mut Option<u32>,
+        target_fps: &mut Option<f32>,
+    ) {
+        ui.add_space(4.0);
+        ui.label("Media Path:");
+        ui.horizontal(|ui| {
+            ui.text_edit_singleline(path);
+            if ui.button("????").on_hover_text("Select File").clicked() {
+                if let Some(file_path) = rfd::FileDialog::new().pick_file() {
+                    *path = file_path.to_string_lossy().to_string();
+                }
+            }
+        });
+
+        ui.add_space(8.0);
+        ui.separator();
+        ui.label("Output Scaling (Optional):");
+
+        // Target Width
+        ui.horizontal(|ui| {
+            let mut use_width = target_width.is_some();
+            if ui.checkbox(&mut use_width, "Width:").changed() {
+                *target_width = if use_width { Some(1920) } else { None };
+            }
+            if let Some(w) = target_width {
+                let mut val = *w as i32;
+                if ui
+                    .add(egui::DragValue::new(&mut val).range(1..=7680).speed(10))
+                    .changed()
+                {
+                    *w = val.max(1) as u32;
+                }
+            } else {
+                ui.label("(Original)");
+            }
+        });
+
+        // Target Height
+        ui.horizontal(|ui| {
+            let mut use_height = target_height.is_some();
+            if ui.checkbox(&mut use_height, "Height:").changed() {
+                *target_height = if use_height { Some(1080) } else { None };
+            }
+            if let Some(h) = target_height {
+                let mut val = *h as i32;
+                if ui
+                    .add(egui::DragValue::new(&mut val).range(1..=4320).speed(10))
+                    .changed()
+                {
+                    *h = val.max(1) as u32;
+                }
+            } else {
+                ui.label("(Original)");
+            }
+        });
+
+        // Target FPS
+        ui.horizontal(|ui| {
+            let mut use_fps = target_fps.is_some();
+            if ui.checkbox(&mut use_fps, "FPS:").changed() {
+                *target_fps = if use_fps { Some(30.0) } else { None };
+            }
+            if let Some(fps) = target_fps {
+                ui.add(egui::Slider::new(fps, 1.0..=120.0).suffix(" fps"));
+            } else {
+                ui.label("(Original)");
+            }
+        });
+
+        // Preset buttons
+        ui.add_space(4.0);
+        ui.horizontal(|ui| {
+            if ui.small_button("720p").clicked() {
+                *target_width = Some(1280);
+                *target_height = Some(720);
+            }
+            if ui.small_button("1080p").clicked() {
+                *target_width = Some(1920);
+                *target_height = Some(1080);
+            }
+            if ui.small_button("Original").clicked() {
+                *target_width = None;
+                *target_height = None;
+                *target_fps = None;
+            }
+        });
+    }
+
     /// Create default presets/templates
     fn default_presets() -> Vec<ModulePreset> {
         use mapmap_core::module::*;
