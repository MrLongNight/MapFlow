//! System for evaluating the module graph and generating actions.

use crate::module::{MapFlowModule, ModulePartType};
use crate::trigger_system::{ActiveTriggers, TriggerSystem};
use std::collections::HashSet;

/// Actions to be executed by the main application, generated by the module evaluator.
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum ModuleAction {
    /// Request to play a media source.
    PlayMedia(u64),
    /// Placeholder for other future actions.
    NoOp,
}

#[derive(Default)]
pub struct ModuleEvaluator {}

impl ModuleEvaluator {
    pub fn new() -> Self {
        Self::default()
    }

    /// Evaluate the module graph and return a list of actions to execute.
    pub fn evaluate(
        &self,
        module: &MapFlowModule,
        active_triggers: &ActiveTriggers,
    ) -> Vec<ModuleAction> {
        let mut actions = Vec::new();
        let mut triggered_inputs = HashSet::new();

        // 1. Identify all active inputs based on active triggers and connections.
        for conn in &module.connections {
            if active_triggers.contains(&(conn.from_part, conn.from_socket)) {
                triggered_inputs.insert((conn.to_part, conn.to_socket));
            }
        }

        // 2. Iterate through parts and generate actions if their inputs are triggered.
        for part in &module.parts {
            match &part.part_type {
                ModulePartType::Source(_) => {
                    // Media sources have one trigger input at socket 0.
                    if triggered_inputs.contains(&(part.id, 0)) {
                        actions.push(ModuleAction::PlayMedia(part.id));
                    }
                }
                // TODO: Handle other part types (masks, effects, etc.) here.
                _ => {}
            }
        }

        actions
    }
}
