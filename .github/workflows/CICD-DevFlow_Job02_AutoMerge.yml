name: "CICD-DevFlow: Job02 Auto-Merge"

on:
  pull_request:
    types: [labeled, synchronize, opened, reopened]
  check_suite:
    types: [completed]
  workflow_run:
    workflows: ["CICD-DevFlow: Job01 Validation"]
    types: [completed]

env:
  # Master Switch
  AUTO_MERGE_ENABLED: true

permissions:
  contents: write
  pull-requests: write
  issues: write
  checks: read

jobs:
  auto-merge:
    name: Auto-Merge
    runs-on: ubuntu-latest
    if: github.event.pull_request != null || github.event.workflow_run != null || github.event.check_suite != null
    steps:
      - name: Auto-Merge Logic
        uses: actions/github-script@v7
        with:
          script: |
            if (process.env.AUTO_MERGE_ENABLED !== 'true') {
              console.log("‚ö†Ô∏è Auto-merge is disabled via AUTO_MERGE_ENABLED");
              return;
            }

            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // 1. IDENTIFY PR
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            let prNumber = context.payload.pull_request?.number;

            // If triggered by workflow_run, find PR associated with commit
            if (!prNumber && context.payload.workflow_run) {
              const prs = await github.rest.pulls.list({
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'open',
                head: `${context.repo.owner}:${context.payload.workflow_run.head_branch}`
              });
              if (prs.data.length > 0) prNumber = prs.data[0].number;
            }

            // If triggered by check_suite
            if (!prNumber && context.payload.check_suite) {
              const prs = await github.rest.pulls.list({
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'open'
              });
              // Filter by SHA
              const match = prs.data.find(p => p.head.sha === context.payload.check_suite.head_sha);
              if (match) prNumber = match.number;
            }

            if (!prNumber) {
              console.log("‚ÑπÔ∏è No PR found for this event.");
              return;
            }

            console.log(`üîç Checking PR #${prNumber} for Auto-Merge eligibility...`);

            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // 2. GET PR DATA
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            const pr = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });

            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // 3. PRE-CHECKS
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

            // Check: Draft PR
            if (pr.data.draft) {
              console.log("‚ùå PR is a draft. Skipping auto-merge.");
              return;
            }

            // Check: Mergeable state
            if (pr.data.mergeable === false) {
              console.log("‚ùå PR has merge conflicts. Cannot auto-merge.");
              return;
            }

            if (pr.data.mergeable_state === 'dirty') {
              console.log("‚ùå PR mergeable_state is 'dirty'. Skipping auto-merge.");
              return;
            }

            // Check: Already merged
            if (pr.data.merged) {
              console.log("‚ÑπÔ∏è PR is already merged.");
              return;
            }

            // Check: Closed
            if (pr.data.state === 'closed') {
              console.log("‚ÑπÔ∏è PR is closed.");
              return;
            }

            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // 4. CHECK STATUS CHECKS
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

            console.log(`üìä Fetching check suites for commit ${pr.data.head.sha}...`);

            const suites = await github.rest.checks.listSuitesForRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: pr.data.head.sha
            });

            console.log(`Found ${suites.data.total_count} check suite(s)`);

            // If no checks exist at all, this might be a docs-only change
            // We still allow merge (you can change this behavior if needed)
            if (suites.data.total_count === 0) {
              console.log("‚ö†Ô∏è No check suites found. This might be a documentation-only PR.");
              console.log("‚úÖ Proceeding with merge (no checks to fail).");
            } else {
              // Check for failures
              const failed = suites.data.check_suites.filter(s =>
                s.conclusion === 'failure' ||
                s.conclusion === 'timed_out' ||
                s.conclusion === 'cancelled'
              );

              if (failed.length > 0) {
                console.log(`‚ùå ${failed.length} check suite(s) failed:`);
                failed.forEach(s => console.log(`  - ${s.app.name}: ${s.conclusion}`));
                return;
              }

              // Check for pending/in-progress
              const pending = suites.data.check_suites.filter(s =>
                s.status === 'in_progress' ||
                s.status === 'queued' ||
                s.status === 'waiting'
              );

              if (pending.length > 0) {
                console.log(`‚è≥ ${pending.length} check suite(s) still running:`);
                pending.forEach(s => console.log(`  - ${s.app.name}: ${s.status}`));
                return;
              }

              // Check for successful completion
              const successful = suites.data.check_suites.filter(s =>
                s.conclusion === 'success'
              );

              console.log(`‚úÖ ${successful.length}/${suites.data.total_count} check suite(s) passed`);

              // Ensure ALL checks have completed successfully
              const completed = suites.data.check_suites.filter(s =>
                s.status === 'completed'
              );

              if (completed.length !== suites.data.total_count) {
                console.log(`‚è≥ Waiting for all checks to complete (${completed.length}/${suites.data.total_count})`);
                return;
              }

              // Ensure all completed checks are successful
              if (successful.length !== completed.length) {
                console.log(`‚ùå Not all completed checks are successful`);
                return;
              }
            }

            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // 5. EXECUTE MERGE
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

            console.log("‚úÖ All conditions met. Initiating auto-merge...");

            try {
              await github.rest.pulls.merge({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber,
                merge_method: 'squash',
                commit_title: `${pr.data.title} (#${prNumber})`,
                commit_message: `${pr.data.body || ''}\n\nAuto-merged by GitHub Actions`
              });

              console.log("üéâ PR merged successfully!");

              const linkedIssues = new Set();
              const textToScan = `${pr.data.title || ''}\n${pr.data.body || ''}`;
              const closingIssueRegex = /\b(?:close(?:s|d|ing)?|fix(?:es|ed|ing)?|resolve(?:s|d|ing)?)\s*:?\s*((?:#\d+\s*(?:,\s*#\d+\s*)*))/gi;
              for (const match of textToScan.matchAll(closingIssueRegex)) {
                for (const issueMatch of match[1].matchAll(/#(\d+)/g)) {
                  const issueNumber = Number.parseInt(issueMatch[1], 10);
                  if (Number.isInteger(issueNumber) && issueNumber > 0) {
                    linkedIssues.add(issueNumber);
                  }
                }
              }

              for (const issueNumber of linkedIssues) {
                try {
                  const issue = await github.rest.issues.get({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issueNumber
                  });

                  if (issue.data.pull_request) {
                    console.log(`‚ÑπÔ∏è #${issueNumber} is a pull request, skipping issue closure.`);
                    continue;
                  }

                  if (issue.data.state === 'open') {
                    await github.rest.issues.createComment({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: issueNumber,
                      body: `‚úÖ This issue was automatically closed after successful merge of PR #${prNumber}.`
                    });
                    await github.rest.issues.update({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: issueNumber,
                      state: 'closed'
                    });
                    console.log(`‚úÖ Closed linked issue #${issueNumber}`);
                  }
                } catch (closeError) {
                  console.log(`‚ö†Ô∏è Failed to close linked issue #${issueNumber}: ${closeError.message}`);
                }
              }

              // Optional: Add a comment to the PR
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: '‚úÖ **Auto-merged** by CI/CD pipeline after all checks passed.'
              });

            } catch (e) {
              console.log(`‚ùå Merge failed: ${e.message}`);

              // Add error comment to PR
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: `‚ö†Ô∏è **Auto-merge failed**: ${e.message}\n\nPlease merge manually.`
              });
            }
