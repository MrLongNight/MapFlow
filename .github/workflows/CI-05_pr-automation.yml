name: "CI-05: PR Auto-Merge"

on:
  pull_request:
    types: [opened, synchronize, reopened, labeled]
  check_suite:
    types: [completed]
  workflow_run:
    workflows: ["CI-01:Build&Test"]
    types: [completed]
  workflow_dispatch:

env:
  # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  # MASTER SWITCH - Set to 'false' to disable ALL Jules automation
  # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  JULES_AUTOMATION_ENABLED: true
  # Set to 'false' to disable auto-merge only (keeps other automation)
  AUTO_MERGE_ENABLED: true

permissions:
  contents: write
  pull-requests: write
  issues: write
  checks: read

jobs:
  # Auto-merge for Jules PRs with failure handling
  auto-merge:
    name: Auto-Merge Jules PR
    runs-on: ubuntu-latest
    env:
      JULES_AUTOMATION_ENABLED: "true"
      FIND_PR_NUMBER: ''
      HAS_PR: 'false'
    if: | 
      (github.event.pull_request &&
       (contains(github.event.pull_request.labels.*.name, 'jules-pr') || 
        contains(github.event.pull_request.labels.*.name, 'jules-task') ||
        contains(github.event.pull_request.body, 'Created by Jules')) &&
       github.event.pull_request.draft == false) ||
      (github.event.workflow_run &&
       github.event.workflow_run.conclusion != 'skipped') ||
      (github.event.check_suite &&
       github.event.check_suite.conclusion != 'skipped') ||
      github.event_name == 'workflow_dispatch'

    steps:
    - name: Find Jules PR for workflow run or check suite
      id: find-pr
      uses: actions/github-script@v7
      with:
        script: |
          // Check conditions internally to satisfy linter
          if ((context.eventName !== 'workflow_run' && context.eventName !== 'check_suite') || process.env.JULES_AUTOMATION_ENABLED !== 'true') {
            core.setOutput('has_pr', 'false');
            core.setOutput('pr_number', '');
            return;
          }

          // Get head_sha from either workflow_run or check_suite
          const headSha = context.payload.workflow_run?.head_sha || context.payload.check_suite?.head_sha;
          if (!headSha) {
            console.log('‚è≠Ô∏è No head_sha found in event payload');
            core.exportVariable('HAS_PR', 'false');
            return;
          }

          console.log(`üîç Looking for PR with head SHA: ${headSha}`);
          
          const { data: prs } = await github.rest.pulls.list({
            owner: context.repo.owner,
            repo: context.repo.repo,
            state: 'open'
          });
          
          // Find PR matching the head SHA with jules-pr, jules-task label or "Created by Jules" in body
          const pr = prs.find(p => 
            p.head.sha === headSha &&
            (p.labels.some(l => l.name === 'jules-pr' || l.name === 'jules-task') || 
             (p.body && p.body.includes('Created by Jules')))
          );
          
          if (pr) {
            console.log(`‚úÖ Found PR #${pr.number} for head SHA ${headSha}`);
            core.exportVariable('FIND_PR_NUMBER', pr.number.toString());
            core.exportVariable('HAS_PR', 'true');
            core.setOutput('pr_number', pr.number);
            core.setOutput('has_pr', 'true');
          } else {
            console.log(`‚è≠Ô∏è No Jules PR found for head SHA ${headSha} (checked labels: jules-pr, jules-task)`);
            core.exportVariable('HAS_PR', 'false');
          }

    - name: Check for check failures and comment if needed
      id: check-failures
      uses: actions/github-script@v7
      with:
        script: |
          // Check master switch
          if (process.env.JULES_AUTOMATION_ENABLED !== 'true') {
            return;
          }

          // Determine PR number
          let prNumber = context.payload.pull_request?.number || process.env.FIND_PR_NUMBER;
          if (!prNumber && context.payload.issue) {
            prNumber = context.payload.issue.number;
          }
          
          if (!prNumber) {
            console.log('‚è≠Ô∏è No PR to process for checks - skipping failure comment');
            return;
          }
          
          prNumber = parseInt(prNumber);
          console.log(`üîç Checking checks for PR #${prNumber}`);
          
          // Get the PR to verify it's a Jules PR
          const { data: pr } = await github.rest.pulls.get({
            owner: context.repo.owner,
            repo: context.repo.repo,
            pull_number: prNumber
          });
          
          // Check if it's a Jules PR (jules-pr, jules-task, or "Created by Jules")
          const isJulesPR = pr.labels.some(l => l.name === 'jules-pr' || l.name === 'jules-task') ||
                           (pr.body && pr.body.includes('Created by Jules'));
          
          if (!isJulesPR) {
            console.log('‚è≠Ô∏è Not a Jules PR - skipping failure comment');
            return;
          }
          
          // Get check suites for the PR
          const headSha = context.payload.pull_request?.head.sha || 
                         context.payload.workflow_run?.head_sha || 
                         context.payload.check_suite?.head_sha ||
                         pr.head.sha;
          
          console.log(`üîç Checking checks for head SHA: ${headSha}`);
          
          const { data: checkSuites } = await github.rest.checks.listSuitesForRef({
            owner: context.repo.owner,
            repo: context.repo.repo,
            ref: headSha
          });
          
          let hasFailures = false;
          let failureDetails = [];
          
          for (const suite of checkSuites.check_suites) {
            const { data: checks } = await github.rest.checks.listForSuite({
              owner: context.repo.owner,
              repo: context.repo.repo,
              check_suite_id: suite.id
            });
            
            for (const check of checks.check_runs) {
              if (check.conclusion === 'failure' || check.conclusion === 'error') {
                hasFailures = true;
                failureDetails.push({
                  name: check.name,
                  url: check.html_url,
                  output: check.output
                });
              }
            }
          }
          
          if (hasFailures) {
            // Check for existing failure comments to avoid duplicates
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber
            });
            
            const existingFailureComment = comments.find(c => 
              c.body && c.body.includes('ü§ñ Copilot-Analyse der Check-Fehler') &&
              c.body.includes(headSha.substring(0, 7))
            );
            
            if (existingFailureComment) {
              console.log('‚è≠Ô∏è Failure comment already exists for this commit - skipping duplicate');
              core.setOutput('has_failures', 'true');
              return;
            }
            
            // Generate analysis with check details and log URLs
            let analysis = `### ü§ñ Copilot-Analyse der Check-Fehler:\n\n`;
            analysis += `**Commit:** ${headSha.substring(0, 7)}\n\n`;
            
            failureDetails.forEach((failure, index) => {
              analysis += `#### Fehler ${index + 1}: ${failure.name}\n`;
              analysis += `**Status:** ‚ùå Failed\n`;
              if (failure.url) {
                analysis += `**Log-URL:** ${failure.url}\n`;
              }
              analysis += `**Meldung:** ${failure.output?.title || 'Keine spezifische Meldung'}\n`;
              if (failure.output?.summary) {
                analysis += `**Details:** ${failure.output.summary}\n`;
              }
              // Basic solution suggestions based on common Rust/CI issues
              if (failure.name.includes('test') && failure.output?.summary?.includes('failed')) {
                analysis += `**L√∂sungsansatz:** √úberpr√ºfe die Testf√§lle auf Assertions-Fehler. F√ºhre \`cargo test -- --nocapture\` lokal aus, um detaillierte Ausgaben zu sehen. Stelle sicher, dass alle Inputs valide sind und keine Nebenwirkungen auftreten.\n\n`;
              } else if (failure.name.includes('clippy') && failure.output?.summary?.includes('warning')) {
                analysis += `**L√∂sungsansatz:** Clippy-Warnungen beheben. F√ºhre \`cargo clippy --fix\` aus, um automatische Korrekturen anzuwenden. √úberpr√ºfe Rust-API-Guidelines f√ºr Stil-Konventionen.\n\n`;
              } else if (failure.name.includes('fmt') && failure.output?.summary?.includes('format')) {
                analysis += `**L√∂sungsansatz:** Code-Formatierung anpassen. F√ºhre \`cargo fmt\` aus, um den Code automatisch zu formatieren.\n\n`;
              } else {
                analysis += `**L√∂sungsansatz:** √úberpr√ºfe die vollst√§ndigen Logs f√ºr weitere Details. Konsultiere die Projekt-Dokumentation in \`docs/\` oder \`AGENTS.md\` f√ºr spezifische Guidelines.\n\n`;
              }
            });
            
            // Comment on PR
            const commentBody = `@jules Es wurden Check-Fehler in diesem PR entdeckt. Bitte behebe sie, um den Auto-Merge zu erm√∂glichen.\n\n${analysis}`;
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body: commentBody
            });
            
            console.log(`‚úÖ Posted failure comment on PR #${prNumber}`);
            core.setOutput('has_failures', 'true');
          } else {
            console.log('‚úÖ No check failures found');
            core.setOutput('has_failures', 'false');
          }

    - name: Auto-merge Jules PR if all checks pass
      id: auto-merge
      uses: actions/github-script@v7
      if: env.JULES_AUTOMATION_ENABLED == 'true'
      with:
        script: |
          // Determine PR number
          let prNumber = context.payload.pull_request?.number || process.env.FIND_PR_NUMBER;
          if (!prNumber && context.payload.issue) {
            prNumber = context.payload.issue.number;
          }
          
          if (!prNumber) {
            console.log('‚è≠Ô∏è No PR to process');
            return;
          }
          
          prNumber = parseInt(prNumber);
          console.log(`ü§ñ Jules PR Auto-Merge: #${prNumber}`);
          
          // Get latest PR state
          const { data: pr } = await github.rest.pulls.get({
            owner: context.repo.owner,
            repo: context.repo.repo,
            pull_number: prNumber
          });
          
          // Check if it's a Jules PR (jules-pr, jules-task, or "Created by Jules")
          const isJulesPR = pr.labels.some(l => l.name === 'jules-pr' || l.name === 'jules-task') || 
                           (pr.body && pr.body.includes('Created by Jules'));
          if (!isJulesPR) {
            console.log('‚è≠Ô∏è Not a Jules PR - skipping');
            return;
          }
          
          // Check mergeable state
          if (pr.mergeable === false) {
            console.log('‚ùå PR is not mergeable');
            return;
          }
          
          // Get check suites
          const { data: checkSuites } = await github.rest.checks.listSuitesForRef({
            owner: context.repo.owner,
            repo: context.repo.repo,
            ref: pr.head.sha
          });
          
          let allChecksPassed = true;
          for (const suite of checkSuites.check_suites) {
            if (suite.conclusion === 'failure' || suite.conclusion === 'error') {
              allChecksPassed = false;
              break;
            }
          }
          
          if (!allChecksPassed) {
            console.log('‚ùå Not all checks passed - cannot auto-merge');
            return;
          }
          
          // Auto-merge if enabled
          if (process.env.AUTO_MERGE_ENABLED === 'true') {
            await github.rest.pulls.merge({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber,
              merge_method: 'squash'
            });
            console.log('‚úÖ Auto-merged Jules PR');
            
            // Update CHANGELOG.md (existing logic, assuming it's in CI-06)
            // Note: Actual changelog update is handled by CI-06_update-changelog.yml
          } else {
            console.log('‚è≠Ô∏è Auto-merge disabled');
          }
