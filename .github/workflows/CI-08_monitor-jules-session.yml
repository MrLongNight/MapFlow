name: "CI-08: Monitor Jules Session"

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CONTINUOUS MONITORING: Runs until all jules-task issues are closed
# or automation is manually disabled
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

on:
  # Triggered by CI-04 when a session is created
  workflow_call:
    inputs:
      session_id:
        description: 'Jules session ID to monitor'
        required: false
        type: string
      issue_number:
        description: 'Related issue number'
        required: false
        type: string
  # Or triggered manually
  workflow_dispatch:
    inputs:
      session_id:
        description: 'Jules session ID to monitor (optional - will find active sessions)'
        required: false
        type: string
      issue_number:
        description: 'Related issue number (optional)'
        required: false
        type: string

permissions:
  contents: write
  pull-requests: write
  issues: write
  actions: write

env:
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # MASTER SWITCH - Set to 'false' to STOP all monitoring
  # This is the only way to stop the continuous monitoring loop
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  JULES_AUTOMATION_ENABLED: true
  
  # Initial delay in seconds (wait for Jules to start coding)
  INITIAL_DELAY_SECONDS: 180  # 3 minutes (optimized)
  
  # Polling interval in seconds - reduced for faster detection
  # Primary: Gmail/PR events via CI-12, Fallback: polling
  POLL_INTERVAL_SECONDS: 300  # 5 minutes (optimized from 30 min)

jobs:
  check-enabled:
    name: Check Automation Status
    runs-on: ubuntu-latest
    outputs:
      enabled: ${{ steps.check.outputs.enabled }}
    steps:
      - name: Check if automation is enabled
        id: check
        run: |
          if [ "${{ env.JULES_AUTOMATION_ENABLED }}" == "true" ]; then
            echo "enabled=true" >> $GITHUB_OUTPUT
            echo "âœ… Jules automation is enabled - continuous monitoring active"
          else
            echo "enabled=false" >> $GITHUB_OUTPUT
            echo "â¹ï¸ Jules automation is DISABLED - stopping monitoring"
          fi

  continuous-monitor:
    name: Continuous Session Monitor
    runs-on: ubuntu-latest
    needs: check-enabled
    if: needs.check-enabled.outputs.enabled == 'true'
    timeout-minutes: 360  # GitHub Actions max is 6 hours per job
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Check JULES_API_KEY secret
        id: check-key
        run: |
          if [ -n "${{ secrets.JULES_API_KEY }}" ]; then
            echo "has_key=true" >> $GITHUB_OUTPUT
            echo "âœ… JULES_API_KEY is configured"
          else
            echo "has_key=false" >> $GITHUB_OUTPUT
            echo "âš ï¸ JULES_API_KEY is NOT configured - skipping monitoring"
          fi

      - name: Continuous monitoring loop
        id: monitor
        if: steps.check-key.outputs.has_key == 'true'
        uses: actions/github-script@v7
        env:
          JULES_API_KEY: ${{ secrets.JULES_API_KEY }}
          SESSION_ID: ${{ github.event.inputs.session_id }}
          ISSUE_NUMBER: ${{ github.event.inputs.issue_number }}
          POLL_INTERVAL: ${{ env.POLL_INTERVAL_SECONDS }}
          INITIAL_DELAY: ${{ env.INITIAL_DELAY_SECONDS }}
        with:
          script: |
            const fetch = globalThis.fetch ?? (await import('node-fetch')).default;
            
            if (!process.env.JULES_API_KEY) {
              core.info('No API key - skipping');
              return;
            }
            
            const pollInterval = parseInt(process.env.POLL_INTERVAL) || 180;
            const initialDelay = parseInt(process.env.INITIAL_DELAY) || 300;
            let checkCount = 0;
            
            core.info('ğŸ”„ Starting CONTINUOUS monitoring (runs until all issues closed or disabled)');
            core.info(`   Initial delay: ${initialDelay} seconds (waiting for Jules to code)`);
            core.info(`   Polling interval: ${pollInterval} seconds`);
            core.info('   To stop: Set JULES_AUTOMATION_ENABLED=false and re-run');
            core.info('');
            
            // Initial delay - wait for Jules to start coding and create PR
            core.info(`â³ Waiting ${initialDelay} seconds before first check...`);
            await new Promise(resolve => setTimeout(resolve, initialDelay * 1000));
            core.info('âœ… Initial delay complete, starting monitoring loop');
            core.info('');
            
            // Main monitoring loop - runs until no more open jules-task issues
            while (true) {
              checkCount++;
              
              // Find all open issues with jules-task label
              const { data: openIssues } = await github.rest.issues.listForRepo({
                owner: context.repo.owner,
                repo: context.repo.repo,
                labels: 'jules-task',
                state: 'open',
                per_page: 100
              });
              
              // Filter out PRs (issues API also returns PRs)
              const actualIssues = openIssues.filter(issue => !issue.pull_request);
              
              if (actualIssues.length === 0) {
                core.info('');
                core.info('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
                core.info('âœ… ALL DONE! No more open jules-task issues.');
                core.info('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
                return;
              }
              
              core.info(`\nâ”â”â” Check #${checkCount} | ${actualIssues.length} open issues â”â”â”`);
              
              // Find sessions to check from issue comments
              let sessionsToCheck = [];
              
              for (const issue of actualIssues) {
                const { data: comments } = await github.rest.issues.listComments({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  per_page: 50
                });
                
                // Check if session already completed (PR exists)
                const { data: prs } = await github.rest.pulls.list({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  state: 'all',
                  per_page: 100
                });
                
                const hasPR = prs.some(pr => 
                  pr.body && pr.body.includes(`#${issue.number}`)
                );
                
                if (hasPR) {
                  core.info(`   #${issue.number}: Has PR, skipping`);
                  continue;
                }
                
                // Find session ID from comments
                let sessionId = null;
                for (const comment of comments) {
                  // Updated regex to match both 'session/' and 'sessions/' in URLs or text
                  let match = comment.body.match(/https?:\/\/[^\s]*?session[s]?\/([a-zA-Z0-9_-]+)/i);
                  if (!match) {
                    match = comment.body.match(/session[s]?[:\s]+([a-zA-Z0-9_-]{10,})/i);
                  }
                  if (match) {
                    sessionId = match[1];
                    break;
                  }
                }
                
                if (sessionId) {
                  sessionsToCheck.push({
                    sessionId,
                    issueNumber: issue.number,
                    issueTitle: issue.title
                  });
                } else {
                  core.info(`   #${issue.number}: No session found yet`);
                }
              }
              
              // Check each session status
              for (const session of sessionsToCheck) {
                core.info(`   #${session.issueNumber}: Checking session ${session.sessionId.substring(0, 10)}...`);
                
                try {
                  const sessionUrl = `https://jules.googleapis.com/v1alpha/sessions/${session.sessionId}`;
                  const res = await fetch(sessionUrl, {
                    method: 'GET',
                    headers: {
                      'X-Goog-Api-Key': process.env.JULES_API_KEY,
                      'Accept': 'application/json'
                    }
                  });
                  
                  if (!res.ok) {
                    core.warning(`      API returned ${res.status}`);
                    continue;
                  }
                  
                  const sessionData = await res.json();
                  const status = sessionData.state || sessionData.status || 'unknown';
                  
                  core.info(`      Status: ${status}`);
                  
                  if (status === 'COMPLETED' || status === 'complete' || status === 'done') {
                    const branch = sessionData.gitPush?.branch || 
                                  sessionData.branch || 
                                  sessionData.pullRequest?.branch ||
                                  sessionData.pullRequest?.head;
                    
                    core.info(`      Session data keys: ${Object.keys(sessionData).join(', ')}`);
                    
                    if (branch) {
                      core.info(`      âœ… Completed with branch: ${branch}`);
                      
                      // Check if branch exists in repository
                      try {
                        await github.rest.repos.getBranch({
                          owner: context.repo.owner,
                          repo: context.repo.repo,
                          branch: branch
                        });
                        core.info(`      âœ… Branch '${branch}' exists in repository`);
                      } catch (branchError) {
                        core.warning(`      âŒ Branch '${branch}' does not exist in repository`);
                        await github.rest.issues.createComment({
                          owner: context.repo.owner,
                          repo: context.repo.repo,
                          issue_number: session.issueNumber,
                          body: `âœ… **Jules session completed!** But branch '${branch}' was not found in the repository. Please check the Jules session and push the branch manually if needed.`
                        });
                        continue; // Skip PR creation
                      }
                      
                      // Check if PR already exists for this branch
                      const existingPR = prs.find(pr => pr.head.ref === branch && pr.state === 'open');
                      
                      if (!existingPR) {
                        // Create PR
                        const { data: repo } = await github.rest.repos.get({
                          owner: context.repo.owner,
                          repo: context.repo.repo
                        });
                        
                        try {
                          const { data: pr } = await github.rest.pulls.create({
                            owner: context.repo.owner,
                            repo: context.repo.repo,
                            title: `Jules: ${session.issueTitle}`,
                            head: branch,
                            base: repo.default_branch || 'main',
                            body: `## Jules Session Completed\n\nAutomated PR for completed Jules session.\n\n**Closes #${session.issueNumber}**`
                          });
                          
                          await github.rest.issues.addLabels({
                            owner: context.repo.owner,
                            repo: context.repo.repo,
                            issue_number: pr.number,
                            labels: ['jules-pr', 'auto-merge']
                          });
                          
                          await github.rest.issues.createComment({
                            owner: context.repo.owner,
                            repo: context.repo.repo,
                            issue_number: session.issueNumber,
                            body: `âœ… **Jules session completed!** PR created: #${pr.number}\n\nThe PR will be automatically merged when all CI checks pass.`
                          });
                          
                          core.info(`      âœ… Created PR #${pr.number}`);
                          
                          // Wait for CI checks to complete (check every 60 seconds for 10 minutes)
                          core.info(`      â³ Waiting for CI checks on PR #${pr.number}...`);
                          let checksComplete = false;
                          let checksPassed = false;
                          let failedChecks = [];
                          
                          for (let i = 0; i < 10 && !checksComplete; i++) {
                            await new Promise(resolve => setTimeout(resolve, 60000)); // Wait 60s
                            
                            const { data: checkRuns } = await github.rest.checks.listForRef({
                              owner: context.repo.owner,
                              repo: context.repo.repo,
                              ref: pr.head.sha
                            });
                            
                            const pending = checkRuns.check_runs.filter(c => c.status !== 'completed');
                            const failed = checkRuns.check_runs.filter(c => c.conclusion === 'failure' || c.conclusion === 'timed_out');
                            
                            if (pending.length === 0) {
                              checksComplete = true;
                              checksPassed = failed.length === 0;
                              failedChecks = failed;
                            } else {
                              core.info(`        Still waiting... ${pending.length} checks pending`);
                            }
                          }
                          
                          if (checksComplete && checksPassed) {
                            // Auto-merge the PR
                            try {
                              await github.rest.pulls.merge({
                                owner: context.repo.owner,
                                repo: context.repo.repo,
                                pull_number: pr.number,
                                merge_method: 'squash'
                              });
                              core.info(`      âœ… Auto-merged PR #${pr.number}`);
                              
                              // Close the issue with summary
                              await github.rest.issues.createComment({
                                owner: context.repo.owner,
                                repo: context.repo.repo,
                                issue_number: session.issueNumber,
                                body: `## âœ… Jules Task Completed!\n\n**PR:** #${pr.number} (merged)\n**Branch:** \`${branch}\`\n\n---\n*Automatically completed by Jules CI/CD Pipeline*`
                              });
                              
                              await github.rest.issues.update({
                                owner: context.repo.owner,
                                repo: context.repo.repo,
                                issue_number: session.issueNumber,
                                state: 'closed'
                              });
                              
                              core.info(`      âœ… Closed issue #${session.issueNumber}`);
                            } catch (mergeErr) {
                              core.warning(`      Could not auto-merge: ${mergeErr.message}`);
                            }
                          } else if (checksComplete && !checksPassed) {
                            // Create @jules comment with error details
                            let errorComment = `@jules CI-Checks sind fehlgeschlagen. Bitte korrigiere die folgenden Fehler:\n\n`;
                            
                            for (const check of failedChecks) {
                              errorComment += `### âŒ ${check.name}\n`;
                              errorComment += `**Status:** ${check.conclusion}\n`;
                              if (check.output && check.output.summary) {
                                errorComment += `**Details:**\n\`\`\`\n${check.output.summary.slice(0, 500)}\n\`\`\`\n\n`;
                              }
                            }
                            
                            errorComment += `\n**NÃ¤chste Schritte:**\n`;
                            errorComment += `1. Analysiere die Fehler oben\n`;
                            errorComment += `2. Pushe Korrekturen zu Branch \`${branch}\`\n`;
                            errorComment += `3. CI lÃ¤uft automatisch erneut\n`;
                            
                            await github.rest.issues.createComment({
                              owner: context.repo.owner,
                              repo: context.repo.repo,
                              issue_number: pr.number,
                              body: errorComment
                            });
                            
                            core.warning(`      âŒ CI checks failed, @jules comment added`);
                          }
                          
                        } catch (prError) {
                          core.warning(`      Could not create PR: ${prError.message}`);
                        }
                      } else {
                        core.info(`      â„¹ï¸ PR already exists for branch '${branch}'`);
                      }
                    } else {
                      core.warning(`      No branch found in session data`);
                      await github.rest.issues.createComment({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        issue_number: session.issueNumber,
                        body: `âœ… **Jules session completed!** No branch detected in session data - please check the session manually.`
                      });
                    }
                    
                  } else if (status === 'FAILED' || status === 'failed' || status === 'error') {
                    core.warning(`      âŒ Session failed`);
                    
                    await github.rest.issues.createComment({
                      owner: context.repo.owner,
                        repo: context.repo.repo,
                        issue_number: session.issueNumber,
                        body: `âš ï¸ **Jules session failed** - Please check the session details and retry if needed.`
                      });
                  } else {
                    core.info(`      â³ Session still in progress: ${status}`);
                  }
                  
                } catch (error) {
                  core.warning(`      Error: ${error.message}`);
                }
              }
              
              // Wait before next check
              core.info(`\nâ³ Waiting ${pollInterval} seconds...`);
              await new Promise(resolve => setTimeout(resolve, pollInterval * 1000));
            }

      - name: Re-trigger self if timeout approaching
        if: "!cancelled()"  # GeÃ¤ndert von 'always()' zu '!cancelled()', um manuelle AbbrÃ¼che zu respektieren
        uses: actions/github-script@v7
        with:
          script: |
            // GitHub Actions has a 6-hour timeout per job
            // Re-trigger this workflow to continue monitoring
            
            // First check if there are still open issues
            const { data: openIssues } = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              labels: 'jules-task',
              state: 'open',
              per_page: 10
            });
            
            const actualIssues = openIssues.filter(issue => !issue.pull_request);
            
            if (actualIssues.length > 0) {
              core.info('ğŸ“¡ Still have open issues - triggering next monitoring cycle...');
              
              try {
                await github.rest.actions.createWorkflowDispatch({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  workflow_id: 'CI-08_monitor-jules-session.yml',
                  ref: 'main'
                });
                core.info('âœ… Next monitoring cycle triggered');
              } catch (error) {
                core.warning('Could not trigger next cycle: ' + error.message);
              }
            } else {
              core.info('âœ… All issues closed - no need to continue monitoring');
            }

      - name: Summary
        if: always()
        run: |
          echo ""
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ“ CI-08: Continuous Monitoring Session"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo ""
          echo "Mode: CONTINUOUS (until all issues closed)"
          echo "Poll Interval: ${{ env.POLL_INTERVAL_SECONDS }} seconds"
          echo ""
          echo "To STOP monitoring:"
          echo "  1. Set JULES_AUTOMATION_ENABLED: false in this file"
          echo "  2. Commit and push"
          echo "  3. Or cancel the running workflow in GitHub Actions"
          echo ""