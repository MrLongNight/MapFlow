name: "CI-08: Monitor Jules Session"

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# OPTIMIZED: Runs on-demand only (triggered by CI-04)
# No more wasteful 5-min scheduled runs - monitors only active sessions
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

on:
  # Triggered by CI-04 when a session is created, or by CI-07 for next session
  workflow_dispatch:
    inputs:
      session_id:
        description: 'Jules session ID to monitor'
        required: false
        type: string
      issue_number:
        description: 'Related issue number'
        required: false
        type: string
      max_checks:
        description: 'Maximum number of status checks (1 min interval)'
        required: false
        type: number
        default: 60

permissions:
  contents: write
  pull-requests: write
  issues: write

env:
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # MASTER SWITCH - Set to 'false' to disable ALL Jules automation
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  JULES_AUTOMATION_ENABLED: true

jobs:
  check-enabled:
    name: Check Automation Status
    runs-on: ubuntu-latest
    outputs:
      enabled: ${{ steps.check.outputs.enabled }}
    steps:
      - name: Check if automation is enabled
        id: check
        run: |
          if [ "${{ env.JULES_AUTOMATION_ENABLED }}" == "true" ]; then
            echo "enabled=true" >> $GITHUB_OUTPUT
            echo "âœ… Jules automation is enabled"
          else
            echo "enabled=false" >> $GITHUB_OUTPUT
            echo "â­ï¸ Jules automation is disabled - skipping"
          fi

  monitor-session:
    name: Monitor Active Session
    runs-on: ubuntu-latest
    needs: check-enabled
    if: needs.check-enabled.outputs.enabled == 'true'
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Check JULES_API_KEY secret
        id: check-key
        run: |
          if [ -n "${{ secrets.JULES_API_KEY }}" ]; then
            echo "has_key=true" >> $GITHUB_OUTPUT
            echo "âœ… JULES_API_KEY is configured"
          else
            echo "has_key=false" >> $GITHUB_OUTPUT
            echo "âš ï¸ JULES_API_KEY is NOT configured - skipping monitoring"
          fi

      - name: Monitor session with 1-minute polling
        id: monitor
        if: steps.check-key.outputs.has_key == 'true'
        uses: actions/github-script@v7
        env:
          JULES_API_KEY: ${{ secrets.JULES_API_KEY }}
          SESSION_ID: ${{ github.event.inputs.session_id }}
          ISSUE_NUMBER: ${{ github.event.inputs.issue_number }}
          MAX_CHECKS: ${{ github.event.inputs.max_checks || '60' }}
        with:
          script: |
            const fetch = globalThis.fetch ?? (await import('node-fetch')).default;
            
            if (!process.env.JULES_API_KEY) {
              core.info('No API key - skipping');
              return;
            }
            
            const sessionId = process.env.SESSION_ID;
            const issueNumber = process.env.ISSUE_NUMBER ? parseInt(process.env.ISSUE_NUMBER) : null;
            const maxChecks = parseInt(process.env.MAX_CHECKS) || 60;
            
            // If no specific session provided, find active sessions from issues
            let sessionsToCheck = [];
            
            if (sessionId && issueNumber) {
              sessionsToCheck.push({ sessionId, issueNumber, issueTitle: `Issue #${issueNumber}` });
            } else {
              // Find active sessions from issue comments
              core.info('No session ID provided, searching for active sessions...');
              const { data: issues } = await github.rest.issues.listForRepo({
                owner: context.repo.owner,
                repo: context.repo.repo,
                labels: 'jules-task',
                state: 'open',
                per_page: 100
              });
              
              for (const issue of issues) {
                const { data: comments } = await github.rest.issues.listComments({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number
                });
                
                for (const comment of comments) {
                  let sessionMatch = comment.body.match(/sessions\/([a-zA-Z0-9_-]+)/);
                  if (!sessionMatch) {
                    sessionMatch = comment.body.match(/session[:\s]+([a-zA-Z0-9_-]{10,})/i);
                  }
                  
                  if (sessionMatch) {
                    sessionsToCheck.push({
                      sessionId: sessionMatch[1],
                      issueNumber: issue.number,
                      issueTitle: issue.title
                    });
                    break;
                  }
                }
              }
            }
            
            if (sessionsToCheck.length === 0) {
              core.info('No active sessions to monitor');
              return;
            }
            
            core.info(`ğŸ“¡ Monitoring ${sessionsToCheck.length} session(s) with 60-second polling...`);
            
            // Poll with 1-minute intervals
            let checkCount = 0;
            
            while (checkCount < maxChecks && sessionsToCheck.length > 0) {
              checkCount++;
              core.info(`\nâ”â”â” Check ${checkCount}/${maxChecks} â”â”â”`);
              
              for (let i = sessionsToCheck.length - 1; i >= 0; i--) {
                const session = sessionsToCheck[i];
                core.info(`ğŸ” Checking session ${session.sessionId} for issue #${session.issueNumber}...`);
                
                try {
                  const sessionUrl = `https://jules.googleapis.com/v1alpha/sessions/${session.sessionId}`;
                  const res = await fetch(sessionUrl, {
                    method: 'GET',
                    headers: {
                      'X-Goog-Api-Key': process.env.JULES_API_KEY,
                      'Accept': 'application/json'
                    }
                  });
                  
                  if (!res.ok) {
                    core.warning(`Session check returned ${res.status}`);
                    continue;
                  }
                  
                  const sessionData = await res.json();
                  const status = sessionData.state || sessionData.status || 'unknown';
                  
                  core.info(`   Status: ${status}`);
                  
                  if (status === 'COMPLETED' || status === 'complete' || status === 'done') {
                    // Session complete - create PR
                    const branch = sessionData.gitPush?.branch || 
                                  sessionData.branch || 
                                  sessionData.pullRequest?.branch ||
                                  sessionData.pullRequest?.head;
                    
                    if (branch) {
                      core.info(`âœ… Session completed with branch: ${branch}`);
                      
                      // Check if PR already exists
                      const { data: prs } = await github.rest.pulls.list({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        state: 'open'
                      });
                      
                      const existingPR = prs.find(pr => pr.head.ref === branch);
                      
                      if (!existingPR) {
                        // Create PR
                        const { data: repo } = await github.rest.repos.get({
                          owner: context.repo.owner,
                          repo: context.repo.repo
                        });
                        
                        const { data: pr } = await github.rest.pulls.create({
                          owner: context.repo.owner,
                          repo: context.repo.repo,
                          title: `Jules: ${session.issueTitle}`,
                          head: branch,
                          base: repo.default_branch || 'main',
                          body: `## Jules Session Completed\n\nAutomated PR for completed Jules session.\n\n**Closes #${session.issueNumber}**\n\nSession: ${sessionUrl}`
                        });
                        
                        await github.rest.issues.addLabels({
                          owner: context.repo.owner,
                          repo: context.repo.repo,
                          issue_number: pr.number,
                          labels: ['jules-pr']
                        });
                        
                        await github.rest.issues.createComment({
                          owner: context.repo.owner,
                          repo: context.repo.repo,
                          issue_number: session.issueNumber,
                          body: `âœ… **Jules session completed!** PR created: #${pr.number}\n\nThe PR will be automatically merged when all CI checks pass.`
                        });
                        
                        core.info(`âœ… Created PR #${pr.number}`);
                      } else {
                        core.info(`â„¹ï¸ PR already exists: #${existingPR.number}`);
                      }
                    } else {
                      await github.rest.issues.createComment({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        issue_number: session.issueNumber,
                        body: `âœ… **Jules session completed!** No branch detected - please check the session and create a PR manually if needed.`
                      });
                    }
                    
                    // Remove from monitoring list
                    sessionsToCheck.splice(i, 1);
                    
                  } else if (status === 'FAILED' || status === 'failed' || status === 'error') {
                    core.warning(`âŒ Session failed for issue #${session.issueNumber}`);
                    
                    await github.rest.issues.createComment({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: session.issueNumber,
                      body: `âš ï¸ **Jules session failed** - Please check the session details and retry if needed.`
                    });
                    
                    sessionsToCheck.splice(i, 1);
                  }
                  // else: session still in progress, keep monitoring
                  
                } catch (error) {
                  core.warning(`Error checking session: ${error.message}`);
                }
              }
              
              // Wait 60 seconds before next check (if sessions remain)
              if (sessionsToCheck.length > 0 && checkCount < maxChecks) {
                core.info('â³ Waiting 60 seconds before next check...');
                await new Promise(resolve => setTimeout(resolve, 60000));
              }
            }
            
            if (sessionsToCheck.length > 0) {
              core.warning(`âš ï¸ Reached max checks (${maxChecks}). Remaining sessions: ${sessionsToCheck.length}`);
              
              // Notify about timeout
              for (const session of sessionsToCheck) {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: session.issueNumber,
                  body: `â±ï¸ **Monitoring timeout** - Session monitoring reached maximum checks (${maxChecks} Ã— 60s). The session may still be in progress. You can manually trigger monitoring again if needed.`
                });
              }
            } else {
              core.info('âœ… All sessions processed successfully');
            }

      - name: Summary
        if: always()
        run: |
          echo ""
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ“ CI-08: Session Monitoring completed"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo ""
          echo "Session ID: ${{ github.event.inputs.session_id }}"
          echo "Issue: ${{ github.event.inputs.issue_number }}"
          echo "Max Checks: ${{ github.event.inputs.max_checks || '60' }}"
          echo ""
